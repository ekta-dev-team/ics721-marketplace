/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, Expiration, Timestamp, Uint64, TokenAmount, Cw1155MintMsgForNullable_Metadata, Metadata, Trait, QueryMsg, Empty, Addr, AllBalancesResponse, Balance, TokenInfoResponseForEmpty, TokensResponse, ApprovedForAllResponse, Approval, BalanceResponse, BatchBalanceResponse, ContractInfoResponse, Null, IsApprovedForAllResponse, MinterResponse, NumTokensResponse, OwnershipForString, ArrayOfTokenApproval, TokenApproval } from "./Cw1155x.types";
import { Cw1155xQueryClient, Cw1155xClient } from "./Cw1155x.client";
export const cw1155xQueryKeys = {
  contract: ([{
    contract: "cw1155x"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...cw1155xQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  balanceOf: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "balance_of",
    args
  }] as const),
  balanceOfBatch: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "balance_of_batch",
    args
  }] as const),
  isApprovedForAll: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "is_approved_for_all",
    args
  }] as const),
  tokenApprovals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "token_approvals",
    args
  }] as const),
  approvalsForAll: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "approvals_for_all",
    args
  }] as const),
  allBalances: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "all_balances",
    args
  }] as const),
  supply: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "supply",
    args
  }] as const),
  numTokens: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "num_tokens",
    args
  }] as const),
  contractInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "contract_info",
    args
  }] as const),
  minter: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "minter",
    args
  }] as const),
  tokenInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "token_info",
    args
  }] as const),
  allTokenInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "all_token_info",
    args
  }] as const),
  tokens: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "tokens",
    args
  }] as const),
  allTokens: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "all_tokens",
    args
  }] as const),
  extension: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "extension",
    args
  }] as const),
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...cw1155xQueryKeys.address(contractAddress)[0],
    method: "ownership",
    args
  }] as const)
};
export const cw1155xQueries = {
  balanceOf: <TData = BalanceResponse,>({
    client,
    args,
    options
  }: Cw1155xBalanceOfQuery<TData>): UseQueryOptions<BalanceResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.balanceOf(client?.contractAddress, args),
    queryFn: () => client ? client.balanceOf({
      owner: args.owner,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  balanceOfBatch: <TData = BatchBalanceResponse,>({
    client,
    args,
    options
  }: Cw1155xBalanceOfBatchQuery<TData>): UseQueryOptions<BatchBalanceResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.balanceOfBatch(client?.contractAddress, args),
    queryFn: () => client ? client.balanceOfBatch({
      owner: args.owner,
      tokenIds: args.tokenIds
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isApprovedForAll: <TData = IsApprovedForAllResponse,>({
    client,
    args,
    options
  }: Cw1155xIsApprovedForAllQuery<TData>): UseQueryOptions<IsApprovedForAllResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.isApprovedForAll(client?.contractAddress, args),
    queryFn: () => client ? client.isApprovedForAll({
      operator: args.operator,
      owner: args.owner
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  tokenApprovals: <TData = ArrayOfTokenApproval,>({
    client,
    args,
    options
  }: Cw1155xTokenApprovalsQuery<TData>): UseQueryOptions<ArrayOfTokenApproval, Error, TData> => ({
    queryKey: cw1155xQueryKeys.tokenApprovals(client?.contractAddress, args),
    queryFn: () => client ? client.tokenApprovals({
      includeExpired: args.includeExpired,
      owner: args.owner,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  approvalsForAll: <TData = ApprovedForAllResponse,>({
    client,
    args,
    options
  }: Cw1155xApprovalsForAllQuery<TData>): UseQueryOptions<ApprovedForAllResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.approvalsForAll(client?.contractAddress, args),
    queryFn: () => client ? client.approvalsForAll({
      includeExpired: args.includeExpired,
      limit: args.limit,
      owner: args.owner,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allBalances: <TData = AllBalancesResponse,>({
    client,
    args,
    options
  }: Cw1155xAllBalancesQuery<TData>): UseQueryOptions<AllBalancesResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.allBalances(client?.contractAddress, args),
    queryFn: () => client ? client.allBalances({
      limit: args.limit,
      startAfter: args.startAfter,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  supply: <TData = NumTokensResponse,>({
    client,
    options
  }: Cw1155xSupplyQuery<TData>): UseQueryOptions<NumTokensResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.supply(client?.contractAddress),
    queryFn: () => client ? client.supply() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  numTokens: <TData = NumTokensResponse,>({
    client,
    args,
    options
  }: Cw1155xNumTokensQuery<TData>): UseQueryOptions<NumTokensResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.numTokens(client?.contractAddress, args),
    queryFn: () => client ? client.numTokens({
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  contractInfo: <TData = ContractInfoResponse,>({
    client,
    options
  }: Cw1155xContractInfoQuery<TData>): UseQueryOptions<ContractInfoResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.contractInfo(client?.contractAddress),
    queryFn: () => client ? client.contractInfo() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  minter: <TData = MinterResponse,>({
    client,
    options
  }: Cw1155xMinterQuery<TData>): UseQueryOptions<MinterResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.minter(client?.contractAddress),
    queryFn: () => client ? client.minter() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  tokenInfo: <TData = TokenInfoResponseForEmpty,>({
    client,
    args,
    options
  }: Cw1155xTokenInfoQuery<TData>): UseQueryOptions<TokenInfoResponseForEmpty, Error, TData> => ({
    queryKey: cw1155xQueryKeys.tokenInfo(client?.contractAddress, args),
    queryFn: () => client ? client.tokenInfo({
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allTokenInfo: <TData = TokenInfoResponseForEmpty,>({
    client,
    args,
    options
  }: Cw1155xAllTokenInfoQuery<TData>): UseQueryOptions<TokenInfoResponseForEmpty, Error, TData> => ({
    queryKey: cw1155xQueryKeys.allTokenInfo(client?.contractAddress, args),
    queryFn: () => client ? client.allTokenInfo({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  tokens: <TData = TokensResponse,>({
    client,
    args,
    options
  }: Cw1155xTokensQuery<TData>): UseQueryOptions<TokensResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.tokens(client?.contractAddress, args),
    queryFn: () => client ? client.tokens({
      limit: args.limit,
      owner: args.owner,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allTokens: <TData = TokensResponse,>({
    client,
    args,
    options
  }: Cw1155xAllTokensQuery<TData>): UseQueryOptions<TokensResponse, Error, TData> => ({
    queryKey: cw1155xQueryKeys.allTokens(client?.contractAddress, args),
    queryFn: () => client ? client.allTokens({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  extension: <TData = Null,>({
    client,
    args,
    options
  }: Cw1155xExtensionQuery<TData>): UseQueryOptions<Null, Error, TData> => ({
    queryKey: cw1155xQueryKeys.extension(client?.contractAddress, args),
    queryFn: () => client ? client.extension({
      msg: args.msg
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  ownership: <TData = OwnershipForString,>({
    client,
    options
  }: Cw1155xOwnershipQuery<TData>): UseQueryOptions<OwnershipForString, Error, TData> => ({
    queryKey: cw1155xQueryKeys.ownership(client?.contractAddress),
    queryFn: () => client ? client.ownership() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface Cw1155xReactQuery<TResponse, TData = TResponse> {
  client: Cw1155xQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface Cw1155xOwnershipQuery<TData> extends Cw1155xReactQuery<OwnershipForString, TData> {}
export function useCw1155xOwnershipQuery<TData = OwnershipForString>({
  client,
  options
}: Cw1155xOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(cw1155xQueryKeys.ownership(client?.contractAddress), () => client ? client.ownership() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xExtensionQuery<TData> extends Cw1155xReactQuery<Null, TData> {
  args: {
    msg: Empty;
  };
}
export function useCw1155xExtensionQuery<TData = Null>({
  client,
  args,
  options
}: Cw1155xExtensionQuery<TData>) {
  return useQuery<Null, Error, TData>(cw1155xQueryKeys.extension(client?.contractAddress, args), () => client ? client.extension({
    msg: args.msg
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xAllTokensQuery<TData> extends Cw1155xReactQuery<TokensResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useCw1155xAllTokensQuery<TData = TokensResponse>({
  client,
  args,
  options
}: Cw1155xAllTokensQuery<TData>) {
  return useQuery<TokensResponse, Error, TData>(cw1155xQueryKeys.allTokens(client?.contractAddress, args), () => client ? client.allTokens({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xTokensQuery<TData> extends Cw1155xReactQuery<TokensResponse, TData> {
  args: {
    limit?: number;
    owner: string;
    startAfter?: string;
  };
}
export function useCw1155xTokensQuery<TData = TokensResponse>({
  client,
  args,
  options
}: Cw1155xTokensQuery<TData>) {
  return useQuery<TokensResponse, Error, TData>(cw1155xQueryKeys.tokens(client?.contractAddress, args), () => client ? client.tokens({
    limit: args.limit,
    owner: args.owner,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xAllTokenInfoQuery<TData> extends Cw1155xReactQuery<TokenInfoResponseForEmpty, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useCw1155xAllTokenInfoQuery<TData = TokenInfoResponseForEmpty>({
  client,
  args,
  options
}: Cw1155xAllTokenInfoQuery<TData>) {
  return useQuery<TokenInfoResponseForEmpty, Error, TData>(cw1155xQueryKeys.allTokenInfo(client?.contractAddress, args), () => client ? client.allTokenInfo({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xTokenInfoQuery<TData> extends Cw1155xReactQuery<TokenInfoResponseForEmpty, TData> {
  args: {
    tokenId: string;
  };
}
export function useCw1155xTokenInfoQuery<TData = TokenInfoResponseForEmpty>({
  client,
  args,
  options
}: Cw1155xTokenInfoQuery<TData>) {
  return useQuery<TokenInfoResponseForEmpty, Error, TData>(cw1155xQueryKeys.tokenInfo(client?.contractAddress, args), () => client ? client.tokenInfo({
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xMinterQuery<TData> extends Cw1155xReactQuery<MinterResponse, TData> {}
export function useCw1155xMinterQuery<TData = MinterResponse>({
  client,
  options
}: Cw1155xMinterQuery<TData>) {
  return useQuery<MinterResponse, Error, TData>(cw1155xQueryKeys.minter(client?.contractAddress), () => client ? client.minter() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xContractInfoQuery<TData> extends Cw1155xReactQuery<ContractInfoResponse, TData> {}
export function useCw1155xContractInfoQuery<TData = ContractInfoResponse>({
  client,
  options
}: Cw1155xContractInfoQuery<TData>) {
  return useQuery<ContractInfoResponse, Error, TData>(cw1155xQueryKeys.contractInfo(client?.contractAddress), () => client ? client.contractInfo() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xNumTokensQuery<TData> extends Cw1155xReactQuery<NumTokensResponse, TData> {
  args: {
    tokenId: string;
  };
}
export function useCw1155xNumTokensQuery<TData = NumTokensResponse>({
  client,
  args,
  options
}: Cw1155xNumTokensQuery<TData>) {
  return useQuery<NumTokensResponse, Error, TData>(cw1155xQueryKeys.numTokens(client?.contractAddress, args), () => client ? client.numTokens({
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xSupplyQuery<TData> extends Cw1155xReactQuery<NumTokensResponse, TData> {}
export function useCw1155xSupplyQuery<TData = NumTokensResponse>({
  client,
  options
}: Cw1155xSupplyQuery<TData>) {
  return useQuery<NumTokensResponse, Error, TData>(cw1155xQueryKeys.supply(client?.contractAddress), () => client ? client.supply() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xAllBalancesQuery<TData> extends Cw1155xReactQuery<AllBalancesResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
    tokenId: string;
  };
}
export function useCw1155xAllBalancesQuery<TData = AllBalancesResponse>({
  client,
  args,
  options
}: Cw1155xAllBalancesQuery<TData>) {
  return useQuery<AllBalancesResponse, Error, TData>(cw1155xQueryKeys.allBalances(client?.contractAddress, args), () => client ? client.allBalances({
    limit: args.limit,
    startAfter: args.startAfter,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xApprovalsForAllQuery<TData> extends Cw1155xReactQuery<ApprovedForAllResponse, TData> {
  args: {
    includeExpired?: boolean;
    limit?: number;
    owner: string;
    startAfter?: string;
  };
}
export function useCw1155xApprovalsForAllQuery<TData = ApprovedForAllResponse>({
  client,
  args,
  options
}: Cw1155xApprovalsForAllQuery<TData>) {
  return useQuery<ApprovedForAllResponse, Error, TData>(cw1155xQueryKeys.approvalsForAll(client?.contractAddress, args), () => client ? client.approvalsForAll({
    includeExpired: args.includeExpired,
    limit: args.limit,
    owner: args.owner,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xTokenApprovalsQuery<TData> extends Cw1155xReactQuery<ArrayOfTokenApproval, TData> {
  args: {
    includeExpired?: boolean;
    owner: string;
    tokenId: string;
  };
}
export function useCw1155xTokenApprovalsQuery<TData = ArrayOfTokenApproval>({
  client,
  args,
  options
}: Cw1155xTokenApprovalsQuery<TData>) {
  return useQuery<ArrayOfTokenApproval, Error, TData>(cw1155xQueryKeys.tokenApprovals(client?.contractAddress, args), () => client ? client.tokenApprovals({
    includeExpired: args.includeExpired,
    owner: args.owner,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xIsApprovedForAllQuery<TData> extends Cw1155xReactQuery<IsApprovedForAllResponse, TData> {
  args: {
    operator: string;
    owner: string;
  };
}
export function useCw1155xIsApprovedForAllQuery<TData = IsApprovedForAllResponse>({
  client,
  args,
  options
}: Cw1155xIsApprovedForAllQuery<TData>) {
  return useQuery<IsApprovedForAllResponse, Error, TData>(cw1155xQueryKeys.isApprovedForAll(client?.contractAddress, args), () => client ? client.isApprovedForAll({
    operator: args.operator,
    owner: args.owner
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xBalanceOfBatchQuery<TData> extends Cw1155xReactQuery<BatchBalanceResponse, TData> {
  args: {
    owner: string;
    tokenIds: string[];
  };
}
export function useCw1155xBalanceOfBatchQuery<TData = BatchBalanceResponse>({
  client,
  args,
  options
}: Cw1155xBalanceOfBatchQuery<TData>) {
  return useQuery<BatchBalanceResponse, Error, TData>(cw1155xQueryKeys.balanceOfBatch(client?.contractAddress, args), () => client ? client.balanceOfBatch({
    owner: args.owner,
    tokenIds: args.tokenIds
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xBalanceOfQuery<TData> extends Cw1155xReactQuery<BalanceResponse, TData> {
  args: {
    owner: string;
    tokenId: string;
  };
}
export function useCw1155xBalanceOfQuery<TData = BalanceResponse>({
  client,
  args,
  options
}: Cw1155xBalanceOfQuery<TData>) {
  return useQuery<BalanceResponse, Error, TData>(cw1155xQueryKeys.balanceOf(client?.contractAddress, args), () => client ? client.balanceOf({
    owner: args.owner,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw1155xRevokeMutation {
  client: Cw1155xClient;
  msg: {
    amount?: Uint128;
    spender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xRevokeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xRevokeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xRevokeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.revoke(msg, fee, memo, funds), options);
}
export interface Cw1155xApproveMutation {
  client: Cw1155xClient;
  msg: {
    amount?: Uint128;
    expires?: Expiration;
    spender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xApproveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xApproveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xApproveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.approve(msg, fee, memo, funds), options);
}
export interface Cw1155xBurnMutation {
  client: Cw1155xClient;
  msg: {
    amount: Uint128;
    from?: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xBurnMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xBurnMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xBurnMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.burn(msg, fee, memo, funds), options);
}
export interface Cw1155xMintMutation {
  client: Cw1155xClient;
  msg: {
    msg: Cw1155MintMsgForNullable_Metadata;
    recipient: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xMintMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xMintMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xMintMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mint(msg, fee, memo, funds), options);
}
export interface Cw1155xSendMutation {
  client: Cw1155xClient;
  msg: {
    amount: Uint128;
    from?: string;
    msg?: Binary;
    to: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xSendMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xSendMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xSendMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.send(msg, fee, memo, funds), options);
}
export interface Cw1155xRevokeAllMutation {
  client: Cw1155xClient;
  msg: {
    operator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xRevokeAllMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xRevokeAllMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xRevokeAllMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.revokeAll(msg, fee, memo, funds), options);
}
export interface Cw1155xApproveAllMutation {
  client: Cw1155xClient;
  msg: {
    expires?: Expiration;
    operator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xApproveAllMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xApproveAllMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xApproveAllMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.approveAll(msg, fee, memo, funds), options);
}
export interface Cw1155xBurnBatchMutation {
  client: Cw1155xClient;
  msg: {
    batch: TokenAmount[];
    from?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xBurnBatchMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xBurnBatchMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xBurnBatchMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.burnBatch(msg, fee, memo, funds), options);
}
export interface Cw1155xMintBatchMutation {
  client: Cw1155xClient;
  msg: {
    msgs: Cw1155MintMsgForNullable_Metadata[];
    recipient: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xMintBatchMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xMintBatchMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xMintBatchMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mintBatch(msg, fee, memo, funds), options);
}
export interface Cw1155xSendBatchMutation {
  client: Cw1155xClient;
  msg: {
    batch: TokenAmount[];
    from?: string;
    msg?: Binary;
    to: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw1155xSendBatchMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw1155xSendBatchMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw1155xSendBatchMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.sendBatch(msg, fee, memo, funds), options);
}