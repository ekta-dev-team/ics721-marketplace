/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin, StdFee } from "@cosmjs/amino";
import { SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Decimal, Uint128, InstantiateMsg, ExecuteMsg, Binary, Cw721ReceiveMsg } from "./JunoMarketplace.types";
export interface JunoMarketplaceInterface {
  contractAddress: string;
  sender: string;
  receiveNft: ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelAuction: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  placeBid: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  settle: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminChangeConfig: ({
    acceptedDenom,
    collectorAddress,
    duration,
    extensionDuration,
    maxRoyaltyFee,
    minIncrement,
    minReservePrice,
    protocolFee
  }: {
    acceptedDenom: string[];
    collectorAddress: string;
    duration: number;
    extensionDuration: number;
    maxRoyaltyFee: Decimal;
    minIncrement: Decimal;
    minReservePrice: Uint128;
    protocolFee: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminCancelAuction: ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setRoyaltyFee: ({
    contractAddr,
    creator,
    royaltyFee
  }: {
    contractAddr: string;
    creator: string;
    royaltyFee: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setRoyaltyAdmin: ({
    address,
    enable
  }: {
    address: string;
    enable: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminPause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminResume: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  settleHook: ({
    nftContract,
    owner,
    tokenId
  }: {
    nftContract: string;
    owner: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class JunoMarketplaceClient implements JunoMarketplaceInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receiveNft = this.receiveNft.bind(this);
    this.cancelAuction = this.cancelAuction.bind(this);
    this.placeBid = this.placeBid.bind(this);
    this.settle = this.settle.bind(this);
    this.adminChangeConfig = this.adminChangeConfig.bind(this);
    this.adminCancelAuction = this.adminCancelAuction.bind(this);
    this.setRoyaltyFee = this.setRoyaltyFee.bind(this);
    this.setRoyaltyAdmin = this.setRoyaltyAdmin.bind(this);
    this.adminPause = this.adminPause.bind(this);
    this.adminResume = this.adminResume.bind(this);
    this.settleHook = this.settleHook.bind(this);
  }
  receiveNft = async ({
    msg,
    sender,
    tokenId
  }: {
    msg: Binary;
    sender: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive_nft: {
        msg,
        sender,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  cancelAuction = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_auction: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  placeBid = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      place_bid: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  settle = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      settle: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  adminChangeConfig = async ({
    acceptedDenom,
    collectorAddress,
    duration,
    extensionDuration,
    maxRoyaltyFee,
    minIncrement,
    minReservePrice,
    protocolFee
  }: {
    acceptedDenom: string[];
    collectorAddress: string;
    duration: number;
    extensionDuration: number;
    maxRoyaltyFee: Decimal;
    minIncrement: Decimal;
    minReservePrice: Uint128;
    protocolFee: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_change_config: {
        accepted_denom: acceptedDenom,
        collector_address: collectorAddress,
        duration,
        extension_duration: extensionDuration,
        max_royalty_fee: maxRoyaltyFee,
        min_increment: minIncrement,
        min_reserve_price: minReservePrice,
        protocol_fee: protocolFee
      }
    }, fee, memo, _funds);
  };
  adminCancelAuction = async ({
    auctionId
  }: {
    auctionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_cancel_auction: {
        auction_id: auctionId
      }
    }, fee, memo, _funds);
  };
  setRoyaltyFee = async ({
    contractAddr,
    creator,
    royaltyFee
  }: {
    contractAddr: string;
    creator: string;
    royaltyFee: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_royalty_fee: {
        contract_addr: contractAddr,
        creator,
        royalty_fee: royaltyFee
      }
    }, fee, memo, _funds);
  };
  setRoyaltyAdmin = async ({
    address,
    enable
  }: {
    address: string;
    enable: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_royalty_admin: {
        address,
        enable
      }
    }, fee, memo, _funds);
  };
  adminPause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_pause: {}
    }, fee, memo, _funds);
  };
  adminResume = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_resume: {}
    }, fee, memo, _funds);
  };
  settleHook = async ({
    nftContract,
    owner,
    tokenId
  }: {
    nftContract: string;
    owner: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      settle_hook: {
        nft_contract: nftContract,
        owner,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}